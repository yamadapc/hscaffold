-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Very simple file/directory structure scaffolding writer monad EDSL
--   
--   See our README on GitHub at
--   <a>https://github.com/yamadapc/hscaffold</a>
@package hscaffold
@version 0.4.0.0

module Hscaffold.Types

-- | The writer monad transformer for scaffold actions
type ScaffoldMonadT m a = WriterT ScaffoldActionV m a

-- | The writer monad for scaffold actions, running in IO
type ScaffoldMonadIO a = WriterT ScaffoldActionV IO a

-- | The writer monad transformer for scaffold actions with an extension
type ScaffoldMonadET e m a = WriterT (ScaffoldAction e) m a

-- | Accumulator for actions
type ScaffoldAction e = [ScaffoldActionType e]

-- | Accumulator for actions set with void extension
type ScaffoldActionV = ScaffoldAction ()

-- | Type of actions scaffolding can make,
--   <a>ScaffoldActionTypeExtension</a> is open for extension through other
--   data-types
data ScaffoldActionType e
File :: FilePath -> Text -> ScaffoldActionType e
Link :: FilePath -> FilePath -> ScaffoldActionType e
Directory :: FilePath -> (ScaffoldAction e) -> ScaffoldActionType e
SetPermissions :: Permissions -> FilePath -> ScaffoldActionType e
Copy :: FilePath -> FilePath -> ScaffoldActionType e
ScaffoldActionTypeExtension :: e -> ScaffoldActionType e
instance GHC.Classes.Ord e => GHC.Classes.Ord (Hscaffold.Types.ScaffoldActionType e)
instance GHC.Classes.Eq e => GHC.Classes.Eq (Hscaffold.Types.ScaffoldActionType e)
instance GHC.Show.Show e => GHC.Show.Show (Hscaffold.Types.ScaffoldActionType e)

module Hscaffold.Interpreter.Haskell

-- | Generates Haskell code from scaffold actions
hscaffoldToHaskell :: Foldable t => t (ScaffoldActionType e) -> Text
hscaffoldActionToHaskell :: ScaffoldActionType e -> [Text]

module Hscaffold.Interpreter.Common

-- | Very simple helper, if the second argument is absolute, returns it,
--   otherwise, return it relative to the first argument
mkActionPath :: FilePath -> FilePath -> FilePath

module Hscaffold.Interpreter.Hsfiles

-- | Run the scaffolding writer and return an <tt>.hsfiles</tt> <a>Text</a>
--   to use with <tt>stack-templates</tt>
toHsfiles :: Writer ScaffoldActionV a -> Text

-- | Convert a single scaffolding action to hsfiles
--   
--   Ignores everything but the <tt>file</tt> directives
actionToHsfile :: FilePath -> ScaffoldActionType e -> [Text]

-- | Shortcut for
--   
--   <pre>
--   writeToHsfiles = do h &lt;- toHsfiles w; liftIO $ Text.writeFile fp h
--   </pre>
writeToHsfiles :: MonadIO m => FilePath -> Writer ScaffoldActionV a -> m ()

module Hscaffold.Interpreter.IO

-- | Run the scaffolding writer on the IO monad with no extensions
--   
--   <pre>
--   runHscaffold "." $ do
--       file "./.gitignore" (Text.unlines [ ".stack-work"
--                                         , "stuff"
--                                         , "here"
--                                         ])
--       directory "./src" $ do
--           file "./Main.hs" "main = putStrLn \"Hello World\""
--           file "./Other.hs" "other = putStrLn \"Hello You\""
--   </pre>
runHscaffold :: MonadIO m => FilePath -> WriterT ScaffoldActionV m a -> m a
runHscaffoldIO :: FilePath -> ScaffoldMonadIO a -> IO a

-- | Run a single scaffolding action on the IO monad with no extensions
runAction :: FilePath -> ScaffoldActionType e -> IO ()

module Hscaffold.Generator.Hsfiles

-- | Converts hsfiles to hscaffold actions
fromHsfiles :: String -> ScaffoldAction e

-- | Converts hsfiles to a hscaffold monad
fromHsfilesW :: MonadWriter (ScaffoldAction e) m => String -> m ()
readHsfiles :: FilePath -> IO (ScaffoldAction e)

module Hscaffold.Generator.Directory

-- | Converts a directory to scaffold actions
hscaffoldFromDirectory :: FilePath -> IO (ScaffoldAction e)

-- | Converts a directory to scaffold actions with a custom filter
--   function. By default we ignore directories starting with <tt>.</tt>
hscaffoldFromDirectoryWith :: ([FilePath] -> [FilePath]) -> FilePath -> IO (ScaffoldAction e)
hscaffoldFromDirectoryWith' :: Traversable t => Bool -> ([FilePath] -> t FilePath) -> FilePath -> IO [ScaffoldActionType e]

module Hscaffold.EDSL

-- | Create a directory with the nested contents
directory :: MonadWriter (ScaffoldAction e) m => FilePath -> WriterT (ScaffoldAction e) m b -> m b

-- | Create a directory with the nested contents and permissions
directoryWith :: MonadWriter (ScaffoldAction e) m => Permissions -> FilePath -> WriterT (ScaffoldAction e) m b -> m b

-- | Create a file with the given contents
file :: MonadWriter (ScaffoldAction e) m => FilePath -> Text -> m ()

-- | Create a file with the given contents and permissions
fileWith :: MonadWriter (ScaffoldAction e) m => Permissions -> FilePath -> Text -> m ()

-- | Set permissions on a filepath
permissions :: MonadWriter (ScaffoldAction e) m => FilePath -> Permissions -> m ()

-- | Create a symbolic link between two filepaths
link :: MonadWriter (ScaffoldAction e) m => FilePath -> FilePath -> m ()

-- | Write the empty string to a file
touch :: MonadWriter (ScaffoldAction e) m => FilePath -> m ()

-- | Write the empty string to a file with given permissions
touchWith :: MonadWriter (ScaffoldAction e) m => Permissions -> FilePath -> m ()

-- | Copy a file from A to B
--   
--   Non-absolute paths are treated relative to the *current* root, nested
--   blocks change the root
copy :: MonadWriter (ScaffoldAction e) m => FilePath -> FilePath -> m ()

-- | Copy a file from A to B and set permissions on B, see <a>copy</a>
copyWith :: MonadWriter (ScaffoldAction e) m => Permissions -> FilePath -> FilePath -> m ()

module Hscaffold

-- | Run the scaffolding writer on the IO monad with no extensions
--   
--   <pre>
--   runHscaffold "." $ do
--       file "./.gitignore" (Text.unlines [ ".stack-work"
--                                         , "stuff"
--                                         , "here"
--                                         ])
--       directory "./src" $ do
--           file "./Main.hs" "main = putStrLn \"Hello World\""
--           file "./Other.hs" "other = putStrLn \"Hello You\""
--   </pre>
runHscaffold :: MonadIO m => FilePath -> WriterT ScaffoldActionV m a -> m a

-- | Run the scaffolding writer and return an <tt>.hsfiles</tt> <a>Text</a>
--   to use with <tt>stack-templates</tt>
toHsfiles :: Writer ScaffoldActionV a -> Text

-- | Shortcut for
--   
--   <pre>
--   writeToHsfiles = do h &lt;- toHsfiles w; liftIO $ Text.writeFile fp h
--   </pre>
writeToHsfiles :: MonadIO m => FilePath -> Writer ScaffoldActionV a -> m ()

-- | Converts hsfiles to hscaffold actions
fromHsfiles :: String -> ScaffoldAction e

-- | Converts hsfiles to a hscaffold monad
fromHsfilesW :: MonadWriter (ScaffoldAction e) m => String -> m ()
readHsfiles :: FilePath -> IO (ScaffoldAction e)

-- | Converts a directory to scaffold actions
hscaffoldFromDirectory :: FilePath -> IO (ScaffoldAction e)

-- | Generates Haskell code from scaffold actions
hscaffoldToHaskell :: Foldable t => t (ScaffoldActionType e) -> Text

-- | Run a single scaffolding action on the IO monad with no extensions
runAction :: FilePath -> ScaffoldActionType e -> IO ()

-- | Unwrap a writer computation as a (result, output) pair. (The inverse
--   of <a>writer</a>.)
runWriter :: Writer w a -> (a, w)
runWriterT :: WriterT w m a -> m (a, w)

-- | Create a directory with the nested contents
directory :: MonadWriter (ScaffoldAction e) m => FilePath -> WriterT (ScaffoldAction e) m b -> m b

-- | Create a file with the given contents
file :: MonadWriter (ScaffoldAction e) m => FilePath -> Text -> m ()

-- | Create a symbolic link between two filepaths
link :: MonadWriter (ScaffoldAction e) m => FilePath -> FilePath -> m ()

-- | Copy a file from A to B
--   
--   Non-absolute paths are treated relative to the *current* root, nested
--   blocks change the root
copy :: MonadWriter (ScaffoldAction e) m => FilePath -> FilePath -> m ()

-- | Write the empty string to a file
touch :: MonadWriter (ScaffoldAction e) m => FilePath -> m ()

-- | Set permissions on a filepath
permissions :: MonadWriter (ScaffoldAction e) m => FilePath -> Permissions -> m ()

-- | Create a file with the given contents and permissions
fileWith :: MonadWriter (ScaffoldAction e) m => Permissions -> FilePath -> Text -> m ()

-- | Create a directory with the nested contents and permissions
directoryWith :: MonadWriter (ScaffoldAction e) m => Permissions -> FilePath -> WriterT (ScaffoldAction e) m b -> m b

-- | Copy a file from A to B and set permissions on B, see <a>copy</a>
copyWith :: MonadWriter (ScaffoldAction e) m => Permissions -> FilePath -> FilePath -> m ()

-- | Write the empty string to a file with given permissions
touchWith :: MonadWriter (ScaffoldAction e) m => Permissions -> FilePath -> m ()
data Permissions :: *

-- | The writer monad transformer for scaffold actions
type ScaffoldMonadT m a = WriterT ScaffoldActionV m a

-- | The writer monad for scaffold actions, running in IO
type ScaffoldMonadIO a = WriterT ScaffoldActionV IO a

-- | Type of actions scaffolding can make,
--   <a>ScaffoldActionTypeExtension</a> is open for extension through other
--   data-types
data ScaffoldActionType e
File :: FilePath -> Text -> ScaffoldActionType e
Link :: FilePath -> FilePath -> ScaffoldActionType e
Directory :: FilePath -> (ScaffoldAction e) -> ScaffoldActionType e
SetPermissions :: Permissions -> FilePath -> ScaffoldActionType e
Copy :: FilePath -> FilePath -> ScaffoldActionType e
ScaffoldActionTypeExtension :: e -> ScaffoldActionType e

-- | Accumulator for actions
type ScaffoldAction e = [ScaffoldActionType e]

-- | Accumulator for actions set with void extension
type ScaffoldActionV = ScaffoldAction ()

-- | The writer monad transformer for scaffold actions with an extension
type ScaffoldMonadET e m a = WriterT (ScaffoldAction e) m a
runHscaffoldIO :: FilePath -> ScaffoldMonadIO a -> IO a

-- | Very simple helper, if the second argument is absolute, returns it,
--   otherwise, return it relative to the first argument
mkActionPath :: FilePath -> FilePath -> FilePath
data Text :: *
